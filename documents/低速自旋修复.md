你遇到的“低速时疯狂自转”是一个非常典型且棘手的车辆动力学仿真问题。

核心原因在于，你的 2DOF 和 3DOF  **动力学模型** （Dynamic Models）中，计算轮胎侧偏角的公式在低速时存在 **数值奇异性（singularity）** ，而你试图用来解决这个问题的**运动学/动力学混合逻辑（blending logic）**没有能完全抑制住这个奇点导致的数值爆炸。

---

### 1. 问题根源：低速奇点（`1/U` 项）

无论是2自由度还是3自由度模型，计算轮胎侧偏角（alpha）都严重依赖于车辆的纵向速度（`U` 或 `vx`）。

* 2DOF ( src/dof_utils.py -> slip_angles_2dof )
  alpha_f = beta + a*r/U - delta_f
  alpha_r = beta - b*r/U - delta_r
* 3DOF ( src/dof_utils.py -> slip_angles_3dof )
  alpha_f = math.atan2(vy + a*r, vx_eff) - df
  alpha_r = math.atan2(vy - b*r, vx_eff) - dr

 **问题在于** ：

当车辆速度 `U` (或 `vx`) 趋近于 0 时：

1. `r/U` 这一项会 **爆炸** （趋近于无穷大）。
2. `atan2(..., vx_eff)` 中的 `vx_eff` 如果处理不当，也会导致物理意义错误。

这种爆炸性的 `alpha` 会产生巨大的轮胎侧向力 `Fy`，`Fy` 再产生巨大的横摆力矩 `Mz`，`Mz` 导致巨大的横摆角加速度 `r_dot`。下一帧 `r` 变得更大，`r/U` 项进一步爆炸，形成 **正反馈** ，车辆开始“疯狂自转”。

---

### 2. 你的（正确的）解决方案：运动学/动力学混合

你在 `src/sim.py` 的 `_step` 函数中，为 2DOF 和 3DOF 模式都实现了一套**低速融合（Kinematic/Dynamic Blending）**逻辑。

* 你计算了一个**动力学导数** (`beta_dot`, `r_dot`)，它在低速时不稳定。
* 你计算了一个**运动学导数** (`beta_dot_kin`, `r_dot_kin`)，它在低速时稳定（不含 `1/U` 项）。
* 你使用一个权重 `w`（基于 `U_mag / U_blend`）来混合这两者。

**理论上，当速度 `U_mag` 很低时，`w` 趋近于 0，仿真器应该只使用 100% 的运动学模型，这应该是稳定的。**

---

### 3. 为什么你的混合逻辑“没拉住”？

尽管混合逻辑存在，但你的仿真依然在低速时自转。这暴露了两个实现上的 **关键缺陷** ：

#### 缺陷一（3DOF模式）：`slip_angles_3dof` 中 `vx_eff` 的错误处理

这是导致 3DOF (魔术公式) 模式自转的主要原因。

在 `src/dof_utils.py` 的 `slip_angles_3dof` 中：

**Python**

```
def slip_angles_3dof(...):
    # vx_eff = max(float(U_min), abs(float(vx)))  <-- 问题在这里
    vx_eff = max(float(U_min), abs(float(vx)))
    alpha_f = math.atan2(float(vy) + float(a) * float(r), vx_eff) - float(df)
    alpha_r = math.atan2(float(vy) - float(b) * float(r), vx_eff) - float(dr)
    return ...
```

`atan2(y, x)` 函数本身对于 `x=0` 是数值安全（会返回 ±π/2）。你**不需要**用 `U_min` (例如 0.5) 来保护它。

错误在于：

当车辆实际速度 vx 极低（例如 0.1 m/s）时，U_min 默认是 0.5（来自 config.yaml）。

你的 vx_eff 被强制设置为了 0.5。

这意味着轮胎模型在计算侧偏角时，以为车辆有 0.5 m/s 的纵向速度，但动力学方程（vy_dot = ... - s.r * s.vx）却在使用实际的 vx = 0.1 m/s。

这种物理状态的 **不一致** （轮胎模型和刚体模型看到的速度不匹配）导致了错误的力和力矩，从而引发不期望的自转。

#### 缺陷二（2DOF模式）：`U_eff` 基于“指令速度”而非“实际速度”

2DOF 模式的问题更严重，它的 `U_eff` 是一个参数，而不是状态。

在 `src/twodof.py` 和 `src/params.py` 中，动力学模型使用的 `U = p.U_eff()`，它基于 `self.ctrl.U`（ **指令速度** ）。

当你的指令速度（`ctrl.U`）降到 0 时，`U_eff` 会被 `U_min` 钳位。你的 `params.py` 默认 `U_min = 0.001`，而 `config.yaml` 是 `0.5`。如果它加载了 `0.001`，`r/U` 项会爆炸到 `r / 0.001`。

虽然 `sim.py` 中的混合权重 `w` 也会变小，但它依然会（错误地）混入一小部分（`w` 权重）的**极其巨大**的、不稳定的动力学导数。这个“爆炸”的导数乘以一个很小的 `w`，其结果依然足以污染稳定的运动学模型，导致自转。

---

### 4. 建议的修复方案

**首选方案：修复 3DOF 模型（最物理真实）**

1. **修改 `src/dof_utils.py` 中的 `slip_angles_3dof`** ：

* 移除 `vx_eff` 的计算。
* 直接将 `float(vx)` 传递给 `atan2`。`atan2` 可以安全处理 `vx = 0` 的情况。

   **Python**

```
   # in src/dof_utils.py
   def slip_angles_3dof(vx: float, vy: float, r: float, df: float, dr: float, a: float, b: float, U_min: float) -> Tuple[float, float]:
       """3DOF 自行车模型侧偏角：使用 arctan2(vy ± a/b * r, vx) - d。
       """
       # vx_eff = max(float(U_min), abs(float(vx)))  <-- [移除]

       # [修改] 直接使用 vx
       alpha_f = math.atan2(float(vy) + float(a) * float(r), float(vx)) - float(df)
       alpha_r = math.atan2(float(vy) - float(b) * float(r), float(vx)) - float(dr)
       return float(alpha_f), float(alpha_r)
```

1. **（可选但推荐）优化 `src/sim.py` 中的 3DOF `_step`** ：

* 在计算混合权重 `w` 后，如果 `w` 接近 0（即处于低速区），**跳过** `derivatives_dfdr`（动力学模型）的计算，因为它既昂贵又不稳定。

   **Python**

```
   # in src/sim.py -> _step() -> 3DOF else block

           # ... (计算 w 之后)
           t = max(0.0, min(1.0, speed_mag / U_blend))
           w = t * t * (3.0 - 2.0 * t)

           # [新增] 低速时跳过昂贵且不稳定的动力学计算
           if w < 0.99: # 如果运动学占主导 (w < 1)
               vx_dot_dyn, vy_dot_dyn, r_dot_dyn = 0.0, 0.0, 0.0
               x_dot_dyn, y_dot_dyn, psi_dot_dyn = 0.0, 0.0, s.r # 保持 psi_dot
           else:
               # 仅在高速时 (w=1) 才计算完整动力学
               ds, aux = derivatives_dfdr(self.state3, df, dr, vp3, Fx_f_pure, Fx_r_pure)
               vx_dot_dyn, vy_dot_dyn, r_dot_dyn, x_dot_dyn, y_dot_dyn, psi_dot_dyn = map(float, ds)

           # 几何：目标横摆率、纵向速度跟踪、侧向速度阻尼与位移沿航向
           kappa = curvature_4ws(df, dr, vp3.L)
           # ... (计算 _kin 导数)

           # [修改] 从 ds 中提取动力学导数（如果上面没有跳过）
           # (vx_dot_dyn, vy_dot_dyn, r_dot_dyn, x_dot_dyn, y_dot_dyn, psi_dot_dyn) 已在 if/else 中定义

           # 混合 (保持不变)
           vx_dot = w * vx_dot_dyn + (1.0 - w) * vx_dot_kin
           vy_dot = w * vy_dot_dyn + (1.0 - w) * vy_dot_kin
           # ... (后续混合与积分)
```

---

**次选方案：快速修复 2DOF 模型（治标不治本）**

如果你必须使用 2DOF 模式，最快的“补丁”是提高 `U_min`，使其与 `U_blend` 匹配，强制“钳位”奇点。

1. **修改 `config.yaml`** （或 `config.json` 和 `src/params.py`）：

* 找到 `vehicle` -> `U_min`，将其值改为与 `U_blend` 相同（例如 `0.3`）。
* `U_min: 0.3`
* `U_blend: 0.3`

这将使 `U_eff` 的最小值与混合区间的上限对齐，混合逻辑 `w` 将能更平滑地从不稳定的动力学（其 `1/U` 项被钳位在 `1/0.3`）过渡到运动学。

 **总结** ：我强烈建议你采用 **首选方案（修复 3DOF）** ，因为它在物理上更正确，并且能从根本上解决低速（包括倒车）时的稳定性问题。
