import numpy as np
from typing import List, Dict, Tuple, Optional
from .twodof import derivatives as deriv_2dof


def nearest_plan_index(plan: List[Dict[str, float]], x: float, y: float) -> int:
    """在参考轨迹中寻找与 (x,y) 最近的点索引。"""
    if not plan:
        return 0
    best_i = 0
    best_d = float("inf")
    for i, p in enumerate(plan):
        dx = float(p.get('x', 0.0)) - x
        dy = float(p.get('y', 0.0)) - y
        d = dx * dx + dy * dy
        if d < best_d:
            best_d = d
            best_i = i
    return best_i


def linearize_2dof(params, x_vec: np.ndarray, df0: float, dr0: float, dt: float) -> Tuple[np.ndarray, np.ndarray]:
    """数值线性化 2DOF 并离散化：返回 (A_d, B_d)。
    连续时间：xdot ≈ A x + B u；离散化：x[k+1] ≈ A_d x[k] + B_d u[k]
    """
    base = deriv_2dof(x_vec, df0, dr0, params)
    xdot0 = np.array(base["xdot"], dtype=float)
    nx = 2
    nu = 2
    A = np.zeros((nx, nx), dtype=float)
    B = np.zeros((nx, nu), dtype=float)
    eps_x = 1e-4
    eps_u = 1e-3
    # A: 对状态求导
    for j in range(nx):
        x_eps = np.array(x_vec, dtype=float)
        x_eps[j] += eps_x
        xdot_eps = np.array(deriv_2dof(x_eps, df0, dr0, params)["xdot"], dtype=float)
        A[:, j] = (xdot_eps - xdot0) / eps_x
    # B: 对控制求导
    u0 = np.array([df0, dr0], dtype=float)
    for j in range(nu):
        u_eps = np.array(u0, dtype=float)
        u_eps[j] += eps_u
        xdot_eps = np.array(deriv_2dof(x_vec, float(u_eps[0]), float(u_eps[1]), params)["xdot"], dtype=float)
        B[:, j] = (xdot_eps - xdot0) / eps_u
    # 离散化（欧拉）
    A_d = np.eye(nx) + A * float(dt)
    B_d = B * float(dt)
    return A_d, B_d


def solve_mpc_2dof(
    state: Dict[str, float],
    ctrl: Dict[str, float],
    params,
    plan: List[Dict[str, float]],
    dt: float,
    H: int = 8,
    Q_beta: float = 0.05,
    Q_r: float = 4.0,
    Q_psi: float = 2.0,
    R_df: float = 0.12,
    R_dr: float = 0.8,
    R_delta_df: float = 0.05,
    R_delta_dr: float = 0.2,
    delta_max: Optional[float] = None,
) -> Tuple[float, float]:
    """无约束 QP 的 2DOF MPC：返回首步 (df_cmd, dr_cmd)。
    - 跟踪序列：r_ref（由参考曲率 κ_ref 给出）与其积分得到的航向 ψ_ref。
    - 侧偏 β 轻权阻尼。
    - 控制变率惩罚抑制抖动，首步相对上一控制。
    """
    if not plan:
        return float(ctrl.get('delta_f', 0.0)), float(ctrl.get('delta_r', 0.0))

    # 初值与离散模型
    x0_raw = np.array([float(state.get('beta', 0.0)), float(state.get('r', 0.0))], dtype=float)
    df0 = float(ctrl.get('delta_f', 0.0))
    dr0 = float(ctrl.get('delta_r', 0.0))
    A_d, B_d = linearize_2dof(params, x0_raw, df0, dr0, dt)

    # 参考 r/ψ 序列（H 步）：直接使用规划的航向角 psi，并用离散 dpsi/dt 得到 r_ref
    def wrap(a: float) -> float:
        return float((a + np.pi) % (2*np.pi) - np.pi)
    x = float(state.get('x', 0.0))
    y = float(state.get('y', 0.0))
    psi0 = float(state.get('psi', 0.0))
    base_i = nearest_plan_index(plan, x, y)
    # 从最近点的后一个开始，取 H+1 个 psi 以计算 H 个差分
    i_start = min(base_i + 1, len(plan) - 1)
    psi_list: List[float] = []
    for k in range(H + 1):
        i_k = min(len(plan) - 1, i_start + k)
        psi_list.append(float(plan[i_k].get('psi', psi0)))
    # r_ref[k] = (psi[k+1] - psi[k]) / dt；psi_ref[k] = psi[k]
    r_ref_seq = np.zeros(H, dtype=float)
    for k in range(H):
        dpsi_k = wrap(psi_list[k + 1] - psi_list[k])
        r_ref_seq[k] = dpsi_k / max(float(dt), 1e-6)
    psi_ref_seq = np.array(psi_list[:H], dtype=float)
    beta_ref_seq = np.zeros_like(r_ref_seq)

    # 堆叠 Φ 与 T
    nx, nu = 2, 2
    Phi = np.zeros((H * nx, nx), dtype=float)
    Tm = np.zeros((H * nx, H * nu), dtype=float)
    Ak = np.eye(nx)
    for k in range(H):
        # 预测未来的状态 x_{k+1}
        Ak_plus_1 = Ak @ A_d
        Phi[k*nx:(k+1)*nx, :] = Ak_plus_1

        # 填充 Tm 矩阵的第 k 行
        # Tm(k,j) 表示 u_j 对 x_{k+1} 的影响
        for j in range(k + 1):
            if k >= j:
                power = k - j
                # A_d^0, A_d^1, ...
                Ad_pow = np.linalg.matrix_power(A_d, power)
                block = Ad_pow @ B_d
                Tm[k*nx:(k+1)*nx, j*nu:(j+1)*nu] = block
        Ak = Ak_plus_1

    # 成本矩阵 Q/R（按步堆叠）
    Qh = np.zeros((H * nx, H * nx), dtype=float)
    Rh = np.zeros((H * nu, H * nu), dtype=float)
    for k in range(H):
        Qk = np.diag([Q_beta, Q_r])
        Rk = np.diag([R_df, R_dr])
        Qh[k*nx:(k+1)*nx, k*nx:(k+1)*nx] = Qk
        Rh[k*nu:(k+1)*nu, k*nu:(k+1)*nu] = Rk

    # 参考状态堆叠（β, r）
    Xref = np.zeros(H * nx, dtype=float)
    for k in range(H):
        Xref[k*nx + 0] = beta_ref_seq[k]
        Xref[k*nx + 1] = r_ref_seq[k]

    # --- 修复 Bug #2: 修正 psi 预测 ---
    # 航向输出映射：Ψ_pred = psi_base_vec + S @ X_seq
    # X_seq = [x_1, ..., x_H]^T
    # ψ_{k+1} = (ψ_0 + r_0*dt) + sum_{i=1}^{k} r_i*dt
    S = np.zeros((H, H * nx), dtype=float)
    for k in range(H):
        # k=0 (ψ_1): 循环 range(0) 不执行
        # k=1 (ψ_2): 循环 i=0 (r_1)
        # k=2 (ψ_3): 循环 i=0 (r_1), i=1 (r_2)
        for i in range(k):
            # i 对应 x_{i+1}，索引是 i*nx + 1
            S[k, i*nx + 1] = float(dt)

    # 初始航向基准：psi_base_k = ψ_0 + r_0*dt
    r0 = float(x0_raw[1])
    psi_base_vec = np.full(H, psi0 + r0 * dt, dtype=float) # <--- 修正：加入 r0 贡献
    Psiref = psi_ref_seq
    # --- 修复 Bug #2 结束 ---

    # 控制变率惩罚 D U - g（首步相对上一控制）
    D = np.zeros((H * nu, H * nu), dtype=float)
    g = np.zeros(H * nu, dtype=float)
    Iu = np.eye(nu)
    u_prev = np.array([df0, dr0], dtype=float)
    for k in range(H):
        D[k*nu:(k+1)*nu, k*nu:(k+1)*nu] = Iu
        if k == 0:
            g[0:nu] = u_prev
        else:
            D[k*nu:(k+1)*nu, (k-1)*nu:k*nu] = -Iu
    R_delta = np.zeros((H * nu, H * nu), dtype=float)
    for k in range(H):
        R_delta[k*nu:(k+1)*nu, k*nu:(k+1)*nu] = np.diag([R_delta_df, R_delta_dr])

    # QP 组装
    Q_psi_h = Q_psi * np.eye(H)
    Hmat = (
        Tm.T @ Qh @ Tm
        + Rh
        + Tm.T @ S.T @ Q_psi_h @ S @ Tm
        + D.T @ R_delta @ D
    )
    fvec = (
        (Phi @ x0_raw - Xref).T @ Qh @ Tm
        + (S @ Phi @ x0_raw + psi_base_vec - Psiref).T @ Q_psi_h @ S @ Tm # <--- 修正：使用 psi_base_vec
        - g.T @ R_delta @ D
    ).T
    
    # --- 修复 Bug #1: 求解 H U = -f ---
    try:
        Useq = np.linalg.solve(Hmat, -fvec) # <--- 修正：加上负号
    except np.linalg.LinAlgError:
        Useq = np.linalg.pinv(Hmat) @ -fvec # <--- 修正：加上负号
    # --- 修复 Bug #1 结束 ---

    df_cmd = float(Useq[0])
    dr_cmd = float(Useq[1]) # <--- 恢复后轮转向
    
    if delta_max is not None:
        df_cmd = float(np.clip(df_cmd, -delta_max, delta_max))
        dr_cmd = float(np.clip(dr_cmd, -delta_max, delta_max))
    return df_cmd, dr_cmd